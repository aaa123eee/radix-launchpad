/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/blakejs";
exports.ids = ["vendor-chunks/blakejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/blakejs/blake2b.js":
/*!*****************************************!*\
  !*** ./node_modules/blakejs/blake2b.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Blake2B in pure Javascript\n// Adapted from the reference implementation in RFC7693\n// Ported to Javascript by DC - https://github.com/dcposch\n\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/blakejs/util.js\")\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += v[b,b+1]\n// v should be a Uint32Array\nfunction ADD64AA (v, a, b) {\n  const o0 = v[a] + v[b]\n  let o1 = v[a + 1] + v[b + 1]\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += b\n// b0 is the low 32 bits of b, b1 represents the high 32 bits\nfunction ADD64AC (v, a, b0, b1) {\n  let o0 = v[a] + b0\n  if (b0 < 0) {\n    o0 += 0x100000000\n  }\n  let o1 = v[a + 1] + b1\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// Little-endian byte access\nfunction B2B_GET32 (arr, i) {\n  return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)\n}\n\n// G Mixing function\n// The ROTRs are inlined for speed\nfunction B2B_G (a, b, c, d, ix, iy) {\n  const x0 = m[ix]\n  const x1 = m[ix + 1]\n  const y0 = m[iy]\n  const y1 = m[iy + 1]\n\n  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s\n  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n  let xor0 = v[d] ^ v[a]\n  let xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = xor1\n  v[d + 1] = xor0\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor0 >>> 24) ^ (xor1 << 8)\n  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)\n\n  ADD64AA(v, a, b)\n  ADD64AC(v, a, y0, y1)\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n  xor0 = v[d] ^ v[a]\n  xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = (xor0 >>> 16) ^ (xor1 << 16)\n  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor1 >>> 31) ^ (xor0 << 1)\n  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)\n}\n\n// Initialization Vector\nconst BLAKE2B_IV32 = new Uint32Array([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372,\n  0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,\n  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19\n])\n\nconst SIGMA8 = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13,\n  6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1,\n  9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4,\n  10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5,\n  15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7,\n  14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2,\n  13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0,\n  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6,\n  1, 12, 0, 2, 11, 7, 5, 3\n]\n\n// These are offsets into a uint64 buffer.\n// Multiply them all by 2 to make them offsets into a uint32 buffer,\n// because this is Javascript and we don't have uint64s\nconst SIGMA82 = new Uint8Array(\n  SIGMA8.map(function (x) {\n    return x * 2\n  })\n)\n\n// Compression function. 'last' flag indicates last block.\n// Note we're representing 16 uint64s as 32 uint32s\nconst v = new Uint32Array(32)\nconst m = new Uint32Array(32)\nfunction blake2bCompress (ctx, last) {\n  let i = 0\n\n  // init work variables\n  for (i = 0; i < 16; i++) {\n    v[i] = ctx.h[i]\n    v[i + 16] = BLAKE2B_IV32[i]\n  }\n\n  // low 64 bits of offset\n  v[24] = v[24] ^ ctx.t\n  v[25] = v[25] ^ (ctx.t / 0x100000000)\n  // high 64 bits not supported, offset may not be higher than 2**53-1\n\n  // last block flag set ?\n  if (last) {\n    v[28] = ~v[28]\n    v[29] = ~v[29]\n  }\n\n  // get little-endian words\n  for (i = 0; i < 32; i++) {\n    m[i] = B2B_GET32(ctx.b, 4 * i)\n  }\n\n  // twelve rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 64)\n  for (i = 0; i < 12; i++) {\n    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)\n    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])\n    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])\n    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])\n    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])\n    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])\n    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])\n    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])\n    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])\n  }\n  // util.debugPrint('   (i=12) v[16]', v, 64)\n\n  for (i = 0; i < 16; i++) {\n    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]\n  }\n  // util.debugPrint('h[8]', ctx.h, 64)\n}\n\n// reusable parameterBlock\nconst parameterBlock = new Uint8Array([\n  0,\n  0,\n  0,\n  0, //  0: outlen, keylen, fanout, depth\n  0,\n  0,\n  0,\n  0, //  4: leaf length, sequential mode\n  0,\n  0,\n  0,\n  0, //  8: node offset\n  0,\n  0,\n  0,\n  0, // 12: node offset\n  0,\n  0,\n  0,\n  0, // 16: node depth, inner length, rfu\n  0,\n  0,\n  0,\n  0, // 20: rfu\n  0,\n  0,\n  0,\n  0, // 24: rfu\n  0,\n  0,\n  0,\n  0, // 28: rfu\n  0,\n  0,\n  0,\n  0, // 32: salt\n  0,\n  0,\n  0,\n  0, // 36: salt\n  0,\n  0,\n  0,\n  0, // 40: salt\n  0,\n  0,\n  0,\n  0, // 44: salt\n  0,\n  0,\n  0,\n  0, // 48: personal\n  0,\n  0,\n  0,\n  0, // 52: personal\n  0,\n  0,\n  0,\n  0, // 56: personal\n  0,\n  0,\n  0,\n  0 // 60: personal\n])\n\n// Creates a BLAKE2b hashing context\n// Requires an output length between 1 and 64 bytes\n// Takes an optional Uint8Array key\n// Takes an optinal Uint8Array salt\n// Takes an optinal Uint8Array personal\nfunction blake2bInit (outlen, key, salt, personal) {\n  if (outlen === 0 || outlen > 64) {\n    throw new Error('Illegal output length, expected 0 < length <= 64')\n  }\n  if (key && key.length > 64) {\n    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')\n  }\n  if (salt && salt.length !== 16) {\n    throw new Error('Illegal salt, expected Uint8Array with length is 16')\n  }\n  if (personal && personal.length !== 16) {\n    throw new Error('Illegal personal, expected Uint8Array with length is 16')\n  }\n\n  // state, 'param block'\n  const ctx = {\n    b: new Uint8Array(128),\n    h: new Uint32Array(16),\n    t: 0, // input count\n    c: 0, // pointer within buffer\n    outlen: outlen // output length in bytes\n  }\n\n  // initialize parameterBlock before usage\n  parameterBlock.fill(0)\n  parameterBlock[0] = outlen\n  if (key) parameterBlock[1] = key.length\n  parameterBlock[2] = 1 // fanout\n  parameterBlock[3] = 1 // depth\n  if (salt) parameterBlock.set(salt, 32)\n  if (personal) parameterBlock.set(personal, 48)\n\n  // initialize hash state\n  for (let i = 0; i < 16; i++) {\n    ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4)\n  }\n\n  // key the hash, if applicable\n  if (key) {\n    blake2bUpdate(ctx, key)\n    // at the end\n    ctx.c = 128\n  }\n\n  return ctx\n}\n\n// Updates a BLAKE2b streaming hash\n// Requires hash context and Uint8Array (byte array)\nfunction blake2bUpdate (ctx, input) {\n  for (let i = 0; i < input.length; i++) {\n    if (ctx.c === 128) {\n      // buffer full ?\n      ctx.t += ctx.c // add counters\n      blake2bCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = input[i]\n  }\n}\n\n// Completes a BLAKE2b streaming hash\n// Returns a Uint8Array containing the message digest\nfunction blake2bFinal (ctx) {\n  ctx.t += ctx.c // mark last block offset\n\n  while (ctx.c < 128) {\n    // fill up with zeros\n    ctx.b[ctx.c++] = 0\n  }\n  blake2bCompress(ctx, true) // final block flag = 1\n\n  // little endian convert and store\n  const out = new Uint8Array(ctx.outlen)\n  for (let i = 0; i < ctx.outlen; i++) {\n    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))\n  }\n  return out\n}\n\n// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array\n//\n// Returns a n-byte Uint8Array\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\n// - salt - optional salt bytes, string, Buffer or Uint8Array\n// - personal - optional personal bytes, string, Buffer or Uint8Array\nfunction blake2b (input, key, outlen, salt, personal) {\n  // preprocess inputs\n  outlen = outlen || 64\n  input = util.normalizeInput(input)\n  if (salt) {\n    salt = util.normalizeInput(salt)\n  }\n  if (personal) {\n    personal = util.normalizeInput(personal)\n  }\n\n  // do the math\n  const ctx = blake2bInit(outlen, key, salt, personal)\n  blake2bUpdate(ctx, input)\n  return blake2bFinal(ctx)\n}\n\n// Computes the BLAKE2B hash of a string or byte array\n//\n// Returns an n-byte hash in hex, all lowercase\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\n// - salt - optional salt bytes, string, Buffer or Uint8Array\n// - personal - optional personal bytes, string, Buffer or Uint8Array\nfunction blake2bHex (input, key, outlen, salt, personal) {\n  const output = blake2b(input, key, outlen, salt, personal)\n  return util.toHex(output)\n}\n\nmodule.exports = {\n  blake2b: blake2b,\n  blake2bHex: blake2bHex,\n  blake2bInit: blake2bInit,\n  blake2bUpdate: blake2bUpdate,\n  blake2bFinal: blake2bFinal\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmxha2Vqcy9ibGFrZTJiLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsb0RBQVE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhdW5jaHBhZC1yYWRpeC8uL25vZGVfbW9kdWxlcy9ibGFrZWpzL2JsYWtlMmIuanM/MWVlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCbGFrZTJCIGluIHB1cmUgSmF2YXNjcmlwdFxuLy8gQWRhcHRlZCBmcm9tIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gaW4gUkZDNzY5M1xuLy8gUG9ydGVkIHRvIEphdmFzY3JpcHQgYnkgREMgLSBodHRwczovL2dpdGh1Yi5jb20vZGNwb3NjaFxuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcblxuLy8gNjQtYml0IHVuc2lnbmVkIGFkZGl0aW9uXG4vLyBTZXRzIHZbYSxhKzFdICs9IHZbYixiKzFdXG4vLyB2IHNob3VsZCBiZSBhIFVpbnQzMkFycmF5XG5mdW5jdGlvbiBBREQ2NEFBICh2LCBhLCBiKSB7XG4gIGNvbnN0IG8wID0gdlthXSArIHZbYl1cbiAgbGV0IG8xID0gdlthICsgMV0gKyB2W2IgKyAxXVxuICBpZiAobzAgPj0gMHgxMDAwMDAwMDApIHtcbiAgICBvMSsrXG4gIH1cbiAgdlthXSA9IG8wXG4gIHZbYSArIDFdID0gbzFcbn1cblxuLy8gNjQtYml0IHVuc2lnbmVkIGFkZGl0aW9uXG4vLyBTZXRzIHZbYSxhKzFdICs9IGJcbi8vIGIwIGlzIHRoZSBsb3cgMzIgYml0cyBvZiBiLCBiMSByZXByZXNlbnRzIHRoZSBoaWdoIDMyIGJpdHNcbmZ1bmN0aW9uIEFERDY0QUMgKHYsIGEsIGIwLCBiMSkge1xuICBsZXQgbzAgPSB2W2FdICsgYjBcbiAgaWYgKGIwIDwgMCkge1xuICAgIG8wICs9IDB4MTAwMDAwMDAwXG4gIH1cbiAgbGV0IG8xID0gdlthICsgMV0gKyBiMVxuICBpZiAobzAgPj0gMHgxMDAwMDAwMDApIHtcbiAgICBvMSsrXG4gIH1cbiAgdlthXSA9IG8wXG4gIHZbYSArIDFdID0gbzFcbn1cblxuLy8gTGl0dGxlLWVuZGlhbiBieXRlIGFjY2Vzc1xuZnVuY3Rpb24gQjJCX0dFVDMyIChhcnIsIGkpIHtcbiAgcmV0dXJuIGFycltpXSBeIChhcnJbaSArIDFdIDw8IDgpIF4gKGFycltpICsgMl0gPDwgMTYpIF4gKGFycltpICsgM10gPDwgMjQpXG59XG5cbi8vIEcgTWl4aW5nIGZ1bmN0aW9uXG4vLyBUaGUgUk9UUnMgYXJlIGlubGluZWQgZm9yIHNwZWVkXG5mdW5jdGlvbiBCMkJfRyAoYSwgYiwgYywgZCwgaXgsIGl5KSB7XG4gIGNvbnN0IHgwID0gbVtpeF1cbiAgY29uc3QgeDEgPSBtW2l4ICsgMV1cbiAgY29uc3QgeTAgPSBtW2l5XVxuICBjb25zdCB5MSA9IG1baXkgKyAxXVxuXG4gIEFERDY0QUEodiwgYSwgYikgLy8gdlthLGErMV0gKz0gdltiLGIrMV0gLi4uIGluIEpTIHdlIG11c3Qgc3RvcmUgYSB1aW50NjQgYXMgdHdvIHVpbnQzMnNcbiAgQURENjRBQyh2LCBhLCB4MCwgeDEpIC8vIHZbYSwgYSsxXSArPSB4IC4uLiB4MCBpcyB0aGUgbG93IDMyIGJpdHMgb2YgeCwgeDEgaXMgdGhlIGhpZ2ggMzIgYml0c1xuXG4gIC8vIHZbZCxkKzFdID0gKHZbZCxkKzFdIHhvciB2W2EsYSsxXSkgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgMzIgYml0c1xuICBsZXQgeG9yMCA9IHZbZF0gXiB2W2FdXG4gIGxldCB4b3IxID0gdltkICsgMV0gXiB2W2EgKyAxXVxuICB2W2RdID0geG9yMVxuICB2W2QgKyAxXSA9IHhvcjBcblxuICBBREQ2NEFBKHYsIGMsIGQpXG5cbiAgLy8gdltiLGIrMV0gPSAodltiLGIrMV0geG9yIHZbYyxjKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDI0IGJpdHNcbiAgeG9yMCA9IHZbYl0gXiB2W2NdXG4gIHhvcjEgPSB2W2IgKyAxXSBeIHZbYyArIDFdXG4gIHZbYl0gPSAoeG9yMCA+Pj4gMjQpIF4gKHhvcjEgPDwgOClcbiAgdltiICsgMV0gPSAoeG9yMSA+Pj4gMjQpIF4gKHhvcjAgPDwgOClcblxuICBBREQ2NEFBKHYsIGEsIGIpXG4gIEFERDY0QUModiwgYSwgeTAsIHkxKVxuXG4gIC8vIHZbZCxkKzFdID0gKHZbZCxkKzFdIHhvciB2W2EsYSsxXSkgcm90YXRlZCByaWdodCBieSAxNiBiaXRzXG4gIHhvcjAgPSB2W2RdIF4gdlthXVxuICB4b3IxID0gdltkICsgMV0gXiB2W2EgKyAxXVxuICB2W2RdID0gKHhvcjAgPj4+IDE2KSBeICh4b3IxIDw8IDE2KVxuICB2W2QgKyAxXSA9ICh4b3IxID4+PiAxNikgXiAoeG9yMCA8PCAxNilcblxuICBBREQ2NEFBKHYsIGMsIGQpXG5cbiAgLy8gdltiLGIrMV0gPSAodltiLGIrMV0geG9yIHZbYyxjKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDYzIGJpdHNcbiAgeG9yMCA9IHZbYl0gXiB2W2NdXG4gIHhvcjEgPSB2W2IgKyAxXSBeIHZbYyArIDFdXG4gIHZbYl0gPSAoeG9yMSA+Pj4gMzEpIF4gKHhvcjAgPDwgMSlcbiAgdltiICsgMV0gPSAoeG9yMCA+Pj4gMzEpIF4gKHhvcjEgPDwgMSlcbn1cblxuLy8gSW5pdGlhbGl6YXRpb24gVmVjdG9yXG5jb25zdCBCTEFLRTJCX0lWMzIgPSBuZXcgVWludDMyQXJyYXkoW1xuICAweGYzYmNjOTA4LCAweDZhMDllNjY3LCAweDg0Y2FhNzNiLCAweGJiNjdhZTg1LCAweGZlOTRmODJiLCAweDNjNmVmMzcyLFxuICAweDVmMWQzNmYxLCAweGE1NGZmNTNhLCAweGFkZTY4MmQxLCAweDUxMGU1MjdmLCAweDJiM2U2YzFmLCAweDliMDU2ODhjLFxuICAweGZiNDFiZDZiLCAweDFmODNkOWFiLCAweDEzN2UyMTc5LCAweDViZTBjZDE5XG5dKVxuXG5jb25zdCBTSUdNQTggPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLFxuICA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsXG4gIDksIDQsIDcsIDksIDMsIDEsIDEzLCAxMiwgMTEsIDE0LCAyLCA2LCA1LCAxMCwgNCwgMCwgMTUsIDgsIDksIDAsIDUsIDcsIDIsIDQsXG4gIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LFxuICAxNSwgMTQsIDEsIDksIDEyLCA1LCAxLCAxNSwgMTQsIDEzLCA0LCAxMCwgMCwgNywgNiwgMywgOSwgMiwgOCwgMTEsIDEzLCAxMSwgNyxcbiAgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTAsIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLFxuICAxMywgNywgMSwgNCwgMTAsIDUsIDEwLCAyLCA4LCA0LCA3LCA2LCAxLCA1LCAxNSwgMTEsIDksIDE0LCAzLCAxMiwgMTMsIDAsIDAsXG4gIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LFxuICAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDNcbl1cblxuLy8gVGhlc2UgYXJlIG9mZnNldHMgaW50byBhIHVpbnQ2NCBidWZmZXIuXG4vLyBNdWx0aXBseSB0aGVtIGFsbCBieSAyIHRvIG1ha2UgdGhlbSBvZmZzZXRzIGludG8gYSB1aW50MzIgYnVmZmVyLFxuLy8gYmVjYXVzZSB0aGlzIGlzIEphdmFzY3JpcHQgYW5kIHdlIGRvbid0IGhhdmUgdWludDY0c1xuY29uc3QgU0lHTUE4MiA9IG5ldyBVaW50OEFycmF5KFxuICBTSUdNQTgubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggKiAyXG4gIH0pXG4pXG5cbi8vIENvbXByZXNzaW9uIGZ1bmN0aW9uLiAnbGFzdCcgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9jay5cbi8vIE5vdGUgd2UncmUgcmVwcmVzZW50aW5nIDE2IHVpbnQ2NHMgYXMgMzIgdWludDMyc1xuY29uc3QgdiA9IG5ldyBVaW50MzJBcnJheSgzMilcbmNvbnN0IG0gPSBuZXcgVWludDMyQXJyYXkoMzIpXG5mdW5jdGlvbiBibGFrZTJiQ29tcHJlc3MgKGN0eCwgbGFzdCkge1xuICBsZXQgaSA9IDBcblxuICAvLyBpbml0IHdvcmsgdmFyaWFibGVzXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdltpXSA9IGN0eC5oW2ldXG4gICAgdltpICsgMTZdID0gQkxBS0UyQl9JVjMyW2ldXG4gIH1cblxuICAvLyBsb3cgNjQgYml0cyBvZiBvZmZzZXRcbiAgdlsyNF0gPSB2WzI0XSBeIGN0eC50XG4gIHZbMjVdID0gdlsyNV0gXiAoY3R4LnQgLyAweDEwMDAwMDAwMClcbiAgLy8gaGlnaCA2NCBiaXRzIG5vdCBzdXBwb3J0ZWQsIG9mZnNldCBtYXkgbm90IGJlIGhpZ2hlciB0aGFuIDIqKjUzLTFcblxuICAvLyBsYXN0IGJsb2NrIGZsYWcgc2V0ID9cbiAgaWYgKGxhc3QpIHtcbiAgICB2WzI4XSA9IH52WzI4XVxuICAgIHZbMjldID0gfnZbMjldXG4gIH1cblxuICAvLyBnZXQgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIG1baV0gPSBCMkJfR0VUMzIoY3R4LmIsIDQgKiBpKVxuICB9XG5cbiAgLy8gdHdlbHZlIHJvdW5kcyBvZiBtaXhpbmdcbiAgLy8gdW5jb21tZW50IHRoZSBEZWJ1Z1ByaW50IGNhbGxzIHRvIGxvZyB0aGUgY29tcHV0YXRpb25cbiAgLy8gYW5kIG1hdGNoIHRoZSBSRkMgc2FtcGxlIGRvY3VtZW50YXRpb25cbiAgLy8gdXRpbC5kZWJ1Z1ByaW50KCcgICAgICAgICAgbVsxNl0nLCBtLCA2NClcbiAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgIChpPScgKyAoaSA8IDEwID8gJyAnIDogJycpICsgaSArICcpIHZbMTZdJywgdiwgNjQpXG4gICAgQjJCX0coMCwgOCwgMTYsIDI0LCBTSUdNQTgyW2kgKiAxNiArIDBdLCBTSUdNQTgyW2kgKiAxNiArIDFdKVxuICAgIEIyQl9HKDIsIDEwLCAxOCwgMjYsIFNJR01BODJbaSAqIDE2ICsgMl0sIFNJR01BODJbaSAqIDE2ICsgM10pXG4gICAgQjJCX0coNCwgMTIsIDIwLCAyOCwgU0lHTUE4MltpICogMTYgKyA0XSwgU0lHTUE4MltpICogMTYgKyA1XSlcbiAgICBCMkJfRyg2LCAxNCwgMjIsIDMwLCBTSUdNQTgyW2kgKiAxNiArIDZdLCBTSUdNQTgyW2kgKiAxNiArIDddKVxuICAgIEIyQl9HKDAsIDEwLCAyMCwgMzAsIFNJR01BODJbaSAqIDE2ICsgOF0sIFNJR01BODJbaSAqIDE2ICsgOV0pXG4gICAgQjJCX0coMiwgMTIsIDIyLCAyNCwgU0lHTUE4MltpICogMTYgKyAxMF0sIFNJR01BODJbaSAqIDE2ICsgMTFdKVxuICAgIEIyQl9HKDQsIDE0LCAxNiwgMjYsIFNJR01BODJbaSAqIDE2ICsgMTJdLCBTSUdNQTgyW2kgKiAxNiArIDEzXSlcbiAgICBCMkJfRyg2LCA4LCAxOCwgMjgsIFNJR01BODJbaSAqIDE2ICsgMTRdLCBTSUdNQTgyW2kgKiAxNiArIDE1XSlcbiAgfVxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgIChpPTEyKSB2WzE2XScsIHYsIDY0KVxuXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgY3R4LmhbaV0gPSBjdHguaFtpXSBeIHZbaV0gXiB2W2kgKyAxNl1cbiAgfVxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJ2hbOF0nLCBjdHguaCwgNjQpXG59XG5cbi8vIHJldXNhYmxlIHBhcmFtZXRlckJsb2NrXG5jb25zdCBwYXJhbWV0ZXJCbG9jayA9IG5ldyBVaW50OEFycmF5KFtcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCwgLy8gIDA6IG91dGxlbiwga2V5bGVuLCBmYW5vdXQsIGRlcHRoXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsIC8vICA0OiBsZWFmIGxlbmd0aCwgc2VxdWVudGlhbCBtb2RlXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsIC8vICA4OiBub2RlIG9mZnNldFxuICAwLFxuICAwLFxuICAwLFxuICAwLCAvLyAxMjogbm9kZSBvZmZzZXRcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCwgLy8gMTY6IG5vZGUgZGVwdGgsIGlubmVyIGxlbmd0aCwgcmZ1XG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsIC8vIDIwOiByZnVcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCwgLy8gMjQ6IHJmdVxuICAwLFxuICAwLFxuICAwLFxuICAwLCAvLyAyODogcmZ1XG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsIC8vIDMyOiBzYWx0XG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsIC8vIDM2OiBzYWx0XG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsIC8vIDQwOiBzYWx0XG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsIC8vIDQ0OiBzYWx0XG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsIC8vIDQ4OiBwZXJzb25hbFxuICAwLFxuICAwLFxuICAwLFxuICAwLCAvLyA1MjogcGVyc29uYWxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCwgLy8gNTY6IHBlcnNvbmFsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAgLy8gNjA6IHBlcnNvbmFsXG5dKVxuXG4vLyBDcmVhdGVzIGEgQkxBS0UyYiBoYXNoaW5nIGNvbnRleHRcbi8vIFJlcXVpcmVzIGFuIG91dHB1dCBsZW5ndGggYmV0d2VlbiAxIGFuZCA2NCBieXRlc1xuLy8gVGFrZXMgYW4gb3B0aW9uYWwgVWludDhBcnJheSBrZXlcbi8vIFRha2VzIGFuIG9wdGluYWwgVWludDhBcnJheSBzYWx0XG4vLyBUYWtlcyBhbiBvcHRpbmFsIFVpbnQ4QXJyYXkgcGVyc29uYWxcbmZ1bmN0aW9uIGJsYWtlMmJJbml0IChvdXRsZW4sIGtleSwgc2FsdCwgcGVyc29uYWwpIHtcbiAgaWYgKG91dGxlbiA9PT0gMCB8fCBvdXRsZW4gPiA2NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBvdXRwdXQgbGVuZ3RoLCBleHBlY3RlZCAwIDwgbGVuZ3RoIDw9IDY0JylcbiAgfVxuICBpZiAoa2V5ICYmIGtleS5sZW5ndGggPiA2NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBrZXksIGV4cGVjdGVkIFVpbnQ4QXJyYXkgd2l0aCAwIDwgbGVuZ3RoIDw9IDY0JylcbiAgfVxuICBpZiAoc2FsdCAmJiBzYWx0Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgc2FsdCwgZXhwZWN0ZWQgVWludDhBcnJheSB3aXRoIGxlbmd0aCBpcyAxNicpXG4gIH1cbiAgaWYgKHBlcnNvbmFsICYmIHBlcnNvbmFsLmxlbmd0aCAhPT0gMTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGVyc29uYWwsIGV4cGVjdGVkIFVpbnQ4QXJyYXkgd2l0aCBsZW5ndGggaXMgMTYnKVxuICB9XG5cbiAgLy8gc3RhdGUsICdwYXJhbSBibG9jaydcbiAgY29uc3QgY3R4ID0ge1xuICAgIGI6IG5ldyBVaW50OEFycmF5KDEyOCksXG4gICAgaDogbmV3IFVpbnQzMkFycmF5KDE2KSxcbiAgICB0OiAwLCAvLyBpbnB1dCBjb3VudFxuICAgIGM6IDAsIC8vIHBvaW50ZXIgd2l0aGluIGJ1ZmZlclxuICAgIG91dGxlbjogb3V0bGVuIC8vIG91dHB1dCBsZW5ndGggaW4gYnl0ZXNcbiAgfVxuXG4gIC8vIGluaXRpYWxpemUgcGFyYW1ldGVyQmxvY2sgYmVmb3JlIHVzYWdlXG4gIHBhcmFtZXRlckJsb2NrLmZpbGwoMClcbiAgcGFyYW1ldGVyQmxvY2tbMF0gPSBvdXRsZW5cbiAgaWYgKGtleSkgcGFyYW1ldGVyQmxvY2tbMV0gPSBrZXkubGVuZ3RoXG4gIHBhcmFtZXRlckJsb2NrWzJdID0gMSAvLyBmYW5vdXRcbiAgcGFyYW1ldGVyQmxvY2tbM10gPSAxIC8vIGRlcHRoXG4gIGlmIChzYWx0KSBwYXJhbWV0ZXJCbG9jay5zZXQoc2FsdCwgMzIpXG4gIGlmIChwZXJzb25hbCkgcGFyYW1ldGVyQmxvY2suc2V0KHBlcnNvbmFsLCA0OClcblxuICAvLyBpbml0aWFsaXplIGhhc2ggc3RhdGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgY3R4LmhbaV0gPSBCTEFLRTJCX0lWMzJbaV0gXiBCMkJfR0VUMzIocGFyYW1ldGVyQmxvY2ssIGkgKiA0KVxuICB9XG5cbiAgLy8ga2V5IHRoZSBoYXNoLCBpZiBhcHBsaWNhYmxlXG4gIGlmIChrZXkpIHtcbiAgICBibGFrZTJiVXBkYXRlKGN0eCwga2V5KVxuICAgIC8vIGF0IHRoZSBlbmRcbiAgICBjdHguYyA9IDEyOFxuICB9XG5cbiAgcmV0dXJuIGN0eFxufVxuXG4vLyBVcGRhdGVzIGEgQkxBS0UyYiBzdHJlYW1pbmcgaGFzaFxuLy8gUmVxdWlyZXMgaGFzaCBjb250ZXh0IGFuZCBVaW50OEFycmF5IChieXRlIGFycmF5KVxuZnVuY3Rpb24gYmxha2UyYlVwZGF0ZSAoY3R4LCBpbnB1dCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN0eC5jID09PSAxMjgpIHtcbiAgICAgIC8vIGJ1ZmZlciBmdWxsID9cbiAgICAgIGN0eC50ICs9IGN0eC5jIC8vIGFkZCBjb3VudGVyc1xuICAgICAgYmxha2UyYkNvbXByZXNzKGN0eCwgZmFsc2UpIC8vIGNvbXByZXNzIChub3QgbGFzdClcbiAgICAgIGN0eC5jID0gMCAvLyBjb3VudGVyIHRvIHplcm9cbiAgICB9XG4gICAgY3R4LmJbY3R4LmMrK10gPSBpbnB1dFtpXVxuICB9XG59XG5cbi8vIENvbXBsZXRlcyBhIEJMQUtFMmIgc3RyZWFtaW5nIGhhc2hcbi8vIFJldHVybnMgYSBVaW50OEFycmF5IGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgZGlnZXN0XG5mdW5jdGlvbiBibGFrZTJiRmluYWwgKGN0eCkge1xuICBjdHgudCArPSBjdHguYyAvLyBtYXJrIGxhc3QgYmxvY2sgb2Zmc2V0XG5cbiAgd2hpbGUgKGN0eC5jIDwgMTI4KSB7XG4gICAgLy8gZmlsbCB1cCB3aXRoIHplcm9zXG4gICAgY3R4LmJbY3R4LmMrK10gPSAwXG4gIH1cbiAgYmxha2UyYkNvbXByZXNzKGN0eCwgdHJ1ZSkgLy8gZmluYWwgYmxvY2sgZmxhZyA9IDFcblxuICAvLyBsaXR0bGUgZW5kaWFuIGNvbnZlcnQgYW5kIHN0b3JlXG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGN0eC5vdXRsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3R4Lm91dGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gY3R4LmhbaSA+PiAyXSA+PiAoOCAqIChpICYgMykpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vLyBDb21wdXRlcyB0aGUgQkxBS0UyQiBoYXNoIG9mIGEgc3RyaW5nIG9yIGJ5dGUgYXJyYXksIGFuZCByZXR1cm5zIGEgVWludDhBcnJheVxuLy9cbi8vIFJldHVybnMgYSBuLWJ5dGUgVWludDhBcnJheVxuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGlucHV0IC0gdGhlIGlucHV0IGJ5dGVzLCBhcyBhIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDY0IGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbi8vIC0gc2FsdCAtIG9wdGlvbmFsIHNhbHQgYnl0ZXMsIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcbi8vIC0gcGVyc29uYWwgLSBvcHRpb25hbCBwZXJzb25hbCBieXRlcywgc3RyaW5nLCBCdWZmZXIgb3IgVWludDhBcnJheVxuZnVuY3Rpb24gYmxha2UyYiAoaW5wdXQsIGtleSwgb3V0bGVuLCBzYWx0LCBwZXJzb25hbCkge1xuICAvLyBwcmVwcm9jZXNzIGlucHV0c1xuICBvdXRsZW4gPSBvdXRsZW4gfHwgNjRcbiAgaW5wdXQgPSB1dGlsLm5vcm1hbGl6ZUlucHV0KGlucHV0KVxuICBpZiAoc2FsdCkge1xuICAgIHNhbHQgPSB1dGlsLm5vcm1hbGl6ZUlucHV0KHNhbHQpXG4gIH1cbiAgaWYgKHBlcnNvbmFsKSB7XG4gICAgcGVyc29uYWwgPSB1dGlsLm5vcm1hbGl6ZUlucHV0KHBlcnNvbmFsKVxuICB9XG5cbiAgLy8gZG8gdGhlIG1hdGhcbiAgY29uc3QgY3R4ID0gYmxha2UyYkluaXQob3V0bGVuLCBrZXksIHNhbHQsIHBlcnNvbmFsKVxuICBibGFrZTJiVXBkYXRlKGN0eCwgaW5wdXQpXG4gIHJldHVybiBibGFrZTJiRmluYWwoY3R4KVxufVxuXG4vLyBDb21wdXRlcyB0aGUgQkxBS0UyQiBoYXNoIG9mIGEgc3RyaW5nIG9yIGJ5dGUgYXJyYXlcbi8vXG4vLyBSZXR1cm5zIGFuIG4tYnl0ZSBoYXNoIGluIGhleCwgYWxsIGxvd2VyY2FzZVxuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGlucHV0IC0gdGhlIGlucHV0IGJ5dGVzLCBhcyBhIHN0cmluZywgQnVmZmVyLCBvciBVaW50OEFycmF5XG4vLyAtIGtleSAtIG9wdGlvbmFsIGtleSBVaW50OEFycmF5LCB1cCB0byA2NCBieXRlc1xuLy8gLSBvdXRsZW4gLSBvcHRpb25hbCBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzLCBkZWZhdWx0IDY0XG4vLyAtIHNhbHQgLSBvcHRpb25hbCBzYWx0IGJ5dGVzLCBzdHJpbmcsIEJ1ZmZlciBvciBVaW50OEFycmF5XG4vLyAtIHBlcnNvbmFsIC0gb3B0aW9uYWwgcGVyc29uYWwgYnl0ZXMsIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcbmZ1bmN0aW9uIGJsYWtlMmJIZXggKGlucHV0LCBrZXksIG91dGxlbiwgc2FsdCwgcGVyc29uYWwpIHtcbiAgY29uc3Qgb3V0cHV0ID0gYmxha2UyYihpbnB1dCwga2V5LCBvdXRsZW4sIHNhbHQsIHBlcnNvbmFsKVxuICByZXR1cm4gdXRpbC50b0hleChvdXRwdXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBibGFrZTJiOiBibGFrZTJiLFxuICBibGFrZTJiSGV4OiBibGFrZTJiSGV4LFxuICBibGFrZTJiSW5pdDogYmxha2UyYkluaXQsXG4gIGJsYWtlMmJVcGRhdGU6IGJsYWtlMmJVcGRhdGUsXG4gIGJsYWtlMmJGaW5hbDogYmxha2UyYkZpbmFsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/blakejs/blake2b.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/blakejs/blake2s.js":
/*!*****************************************!*\
  !*** ./node_modules/blakejs/blake2s.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// BLAKE2s hash function in pure Javascript\n// Adapted from the reference implementation in RFC7693\n// Ported to Javascript by DC - https://github.com/dcposch\n\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/blakejs/util.js\")\n\n// Little-endian byte access.\n// Expects a Uint8Array and an index\n// Returns the little-endian uint32 at v[i..i+3]\nfunction B2S_GET32 (v, i) {\n  return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)\n}\n\n// Mixing function G.\nfunction B2S_G (a, b, c, d, x, y) {\n  v[a] = v[a] + v[b] + x\n  v[d] = ROTR32(v[d] ^ v[a], 16)\n  v[c] = v[c] + v[d]\n  v[b] = ROTR32(v[b] ^ v[c], 12)\n  v[a] = v[a] + v[b] + y\n  v[d] = ROTR32(v[d] ^ v[a], 8)\n  v[c] = v[c] + v[d]\n  v[b] = ROTR32(v[b] ^ v[c], 7)\n}\n\n// 32-bit right rotation\n// x should be a uint32\n// y must be between 1 and 31, inclusive\nfunction ROTR32 (x, y) {\n  return (x >>> y) ^ (x << (32 - y))\n}\n\n// Initialization Vector.\nconst BLAKE2S_IV = new Uint32Array([\n  0x6a09e667,\n  0xbb67ae85,\n  0x3c6ef372,\n  0xa54ff53a,\n  0x510e527f,\n  0x9b05688c,\n  0x1f83d9ab,\n  0x5be0cd19\n])\n\nconst SIGMA = new Uint8Array([\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  14,\n  10,\n  4,\n  8,\n  9,\n  15,\n  13,\n  6,\n  1,\n  12,\n  0,\n  2,\n  11,\n  7,\n  5,\n  3,\n  11,\n  8,\n  12,\n  0,\n  5,\n  2,\n  15,\n  13,\n  10,\n  14,\n  3,\n  6,\n  7,\n  1,\n  9,\n  4,\n  7,\n  9,\n  3,\n  1,\n  13,\n  12,\n  11,\n  14,\n  2,\n  6,\n  5,\n  10,\n  4,\n  0,\n  15,\n  8,\n  9,\n  0,\n  5,\n  7,\n  2,\n  4,\n  10,\n  15,\n  14,\n  1,\n  11,\n  12,\n  6,\n  8,\n  3,\n  13,\n  2,\n  12,\n  6,\n  10,\n  0,\n  11,\n  8,\n  3,\n  4,\n  13,\n  7,\n  5,\n  15,\n  14,\n  1,\n  9,\n  12,\n  5,\n  1,\n  15,\n  14,\n  13,\n  4,\n  10,\n  0,\n  7,\n  6,\n  3,\n  9,\n  2,\n  8,\n  11,\n  13,\n  11,\n  7,\n  14,\n  12,\n  1,\n  3,\n  9,\n  5,\n  0,\n  15,\n  4,\n  8,\n  6,\n  2,\n  10,\n  6,\n  15,\n  14,\n  9,\n  11,\n  3,\n  0,\n  8,\n  12,\n  2,\n  13,\n  7,\n  1,\n  4,\n  10,\n  5,\n  10,\n  2,\n  8,\n  4,\n  7,\n  6,\n  1,\n  5,\n  15,\n  11,\n  9,\n  14,\n  3,\n  12,\n  13,\n  0\n])\n\n// Compression function. \"last\" flag indicates last block\nconst v = new Uint32Array(16)\nconst m = new Uint32Array(16)\nfunction blake2sCompress (ctx, last) {\n  let i = 0\n  for (i = 0; i < 8; i++) {\n    // init work variables\n    v[i] = ctx.h[i]\n    v[i + 8] = BLAKE2S_IV[i]\n  }\n\n  v[12] ^= ctx.t // low 32 bits of offset\n  v[13] ^= ctx.t / 0x100000000 // high 32 bits\n  if (last) {\n    // last block flag set ?\n    v[14] = ~v[14]\n  }\n\n  for (i = 0; i < 16; i++) {\n    // get little-endian words\n    m[i] = B2S_GET32(ctx.b, 4 * i)\n  }\n\n  // ten rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 32)\n  for (i = 0; i < 10; i++) {\n    // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)\n    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]])\n    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]])\n    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]])\n    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]])\n    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]])\n    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]])\n    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]])\n    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]])\n  }\n  // util.debugPrint('   (i=10) v[16]', v, 32)\n\n  for (i = 0; i < 8; i++) {\n    ctx.h[i] ^= v[i] ^ v[i + 8]\n  }\n  // util.debugPrint('h[8]', ctx.h, 32)\n}\n\n// Creates a BLAKE2s hashing context\n// Requires an output length between 1 and 32 bytes\n// Takes an optional Uint8Array key\nfunction blake2sInit (outlen, key) {\n  if (!(outlen > 0 && outlen <= 32)) {\n    throw new Error('Incorrect output length, should be in [1, 32]')\n  }\n  const keylen = key ? key.length : 0\n  if (key && !(keylen > 0 && keylen <= 32)) {\n    throw new Error('Incorrect key length, should be in [1, 32]')\n  }\n\n  const ctx = {\n    h: new Uint32Array(BLAKE2S_IV), // hash state\n    b: new Uint8Array(64), // input block\n    c: 0, // pointer within block\n    t: 0, // input count\n    outlen: outlen // output length in bytes\n  }\n  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen\n\n  if (keylen > 0) {\n    blake2sUpdate(ctx, key)\n    ctx.c = 64 // at the end\n  }\n\n  return ctx\n}\n\n// Updates a BLAKE2s streaming hash\n// Requires hash context and Uint8Array (byte array)\nfunction blake2sUpdate (ctx, input) {\n  for (let i = 0; i < input.length; i++) {\n    if (ctx.c === 64) {\n      // buffer full ?\n      ctx.t += ctx.c // add counters\n      blake2sCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = input[i]\n  }\n}\n\n// Completes a BLAKE2s streaming hash\n// Returns a Uint8Array containing the message digest\nfunction blake2sFinal (ctx) {\n  ctx.t += ctx.c // mark last block offset\n  while (ctx.c < 64) {\n    // fill up with zeros\n    ctx.b[ctx.c++] = 0\n  }\n  blake2sCompress(ctx, true) // final block flag = 1\n\n  // little endian convert and store\n  const out = new Uint8Array(ctx.outlen)\n  for (let i = 0; i < ctx.outlen; i++) {\n    out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xff\n  }\n  return out\n}\n\n// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array\n//\n// Returns a n-byte Uint8Array\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 32 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2s (input, key, outlen) {\n  // preprocess inputs\n  outlen = outlen || 32\n  input = util.normalizeInput(input)\n\n  // do the math\n  const ctx = blake2sInit(outlen, key)\n  blake2sUpdate(ctx, input)\n  return blake2sFinal(ctx)\n}\n\n// Computes the BLAKE2S hash of a string or byte array\n//\n// Returns an n-byte hash in hex, all lowercase\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 32 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2sHex (input, key, outlen) {\n  const output = blake2s(input, key, outlen)\n  return util.toHex(output)\n}\n\nmodule.exports = {\n  blake2s: blake2s,\n  blake2sHex: blake2sHex,\n  blake2sInit: blake2sInit,\n  blake2sUpdate: blake2sUpdate,\n  blake2sFinal: blake2sFinal\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmxha2Vqcy9ibGFrZTJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsb0RBQVE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXVuY2hwYWQtcmFkaXgvLi9ub2RlX21vZHVsZXMvYmxha2Vqcy9ibGFrZTJzLmpzP2Y5MDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQkxBS0UycyBoYXNoIGZ1bmN0aW9uIGluIHB1cmUgSmF2YXNjcmlwdFxuLy8gQWRhcHRlZCBmcm9tIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gaW4gUkZDNzY5M1xuLy8gUG9ydGVkIHRvIEphdmFzY3JpcHQgYnkgREMgLSBodHRwczovL2dpdGh1Yi5jb20vZGNwb3NjaFxuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcblxuLy8gTGl0dGxlLWVuZGlhbiBieXRlIGFjY2Vzcy5cbi8vIEV4cGVjdHMgYSBVaW50OEFycmF5IGFuZCBhbiBpbmRleFxuLy8gUmV0dXJucyB0aGUgbGl0dGxlLWVuZGlhbiB1aW50MzIgYXQgdltpLi5pKzNdXG5mdW5jdGlvbiBCMlNfR0VUMzIgKHYsIGkpIHtcbiAgcmV0dXJuIHZbaV0gXiAodltpICsgMV0gPDwgOCkgXiAodltpICsgMl0gPDwgMTYpIF4gKHZbaSArIDNdIDw8IDI0KVxufVxuXG4vLyBNaXhpbmcgZnVuY3Rpb24gRy5cbmZ1bmN0aW9uIEIyU19HIChhLCBiLCBjLCBkLCB4LCB5KSB7XG4gIHZbYV0gPSB2W2FdICsgdltiXSArIHhcbiAgdltkXSA9IFJPVFIzMih2W2RdIF4gdlthXSwgMTYpXG4gIHZbY10gPSB2W2NdICsgdltkXVxuICB2W2JdID0gUk9UUjMyKHZbYl0gXiB2W2NdLCAxMilcbiAgdlthXSA9IHZbYV0gKyB2W2JdICsgeVxuICB2W2RdID0gUk9UUjMyKHZbZF0gXiB2W2FdLCA4KVxuICB2W2NdID0gdltjXSArIHZbZF1cbiAgdltiXSA9IFJPVFIzMih2W2JdIF4gdltjXSwgNylcbn1cblxuLy8gMzItYml0IHJpZ2h0IHJvdGF0aW9uXG4vLyB4IHNob3VsZCBiZSBhIHVpbnQzMlxuLy8geSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMzEsIGluY2x1c2l2ZVxuZnVuY3Rpb24gUk9UUjMyICh4LCB5KSB7XG4gIHJldHVybiAoeCA+Pj4geSkgXiAoeCA8PCAoMzIgLSB5KSlcbn1cblxuLy8gSW5pdGlhbGl6YXRpb24gVmVjdG9yLlxuY29uc3QgQkxBS0UyU19JViA9IG5ldyBVaW50MzJBcnJheShbXG4gIDB4NmEwOWU2NjcsXG4gIDB4YmI2N2FlODUsXG4gIDB4M2M2ZWYzNzIsXG4gIDB4YTU0ZmY1M2EsXG4gIDB4NTEwZTUyN2YsXG4gIDB4OWIwNTY4OGMsXG4gIDB4MWY4M2Q5YWIsXG4gIDB4NWJlMGNkMTlcbl0pXG5cbmNvbnN0IFNJR01BID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAwLFxuICAxLFxuICAyLFxuICAzLFxuICA0LFxuICA1LFxuICA2LFxuICA3LFxuICA4LFxuICA5LFxuICAxMCxcbiAgMTEsXG4gIDEyLFxuICAxMyxcbiAgMTQsXG4gIDE1LFxuICAxNCxcbiAgMTAsXG4gIDQsXG4gIDgsXG4gIDksXG4gIDE1LFxuICAxMyxcbiAgNixcbiAgMSxcbiAgMTIsXG4gIDAsXG4gIDIsXG4gIDExLFxuICA3LFxuICA1LFxuICAzLFxuICAxMSxcbiAgOCxcbiAgMTIsXG4gIDAsXG4gIDUsXG4gIDIsXG4gIDE1LFxuICAxMyxcbiAgMTAsXG4gIDE0LFxuICAzLFxuICA2LFxuICA3LFxuICAxLFxuICA5LFxuICA0LFxuICA3LFxuICA5LFxuICAzLFxuICAxLFxuICAxMyxcbiAgMTIsXG4gIDExLFxuICAxNCxcbiAgMixcbiAgNixcbiAgNSxcbiAgMTAsXG4gIDQsXG4gIDAsXG4gIDE1LFxuICA4LFxuICA5LFxuICAwLFxuICA1LFxuICA3LFxuICAyLFxuICA0LFxuICAxMCxcbiAgMTUsXG4gIDE0LFxuICAxLFxuICAxMSxcbiAgMTIsXG4gIDYsXG4gIDgsXG4gIDMsXG4gIDEzLFxuICAyLFxuICAxMixcbiAgNixcbiAgMTAsXG4gIDAsXG4gIDExLFxuICA4LFxuICAzLFxuICA0LFxuICAxMyxcbiAgNyxcbiAgNSxcbiAgMTUsXG4gIDE0LFxuICAxLFxuICA5LFxuICAxMixcbiAgNSxcbiAgMSxcbiAgMTUsXG4gIDE0LFxuICAxMyxcbiAgNCxcbiAgMTAsXG4gIDAsXG4gIDcsXG4gIDYsXG4gIDMsXG4gIDksXG4gIDIsXG4gIDgsXG4gIDExLFxuICAxMyxcbiAgMTEsXG4gIDcsXG4gIDE0LFxuICAxMixcbiAgMSxcbiAgMyxcbiAgOSxcbiAgNSxcbiAgMCxcbiAgMTUsXG4gIDQsXG4gIDgsXG4gIDYsXG4gIDIsXG4gIDEwLFxuICA2LFxuICAxNSxcbiAgMTQsXG4gIDksXG4gIDExLFxuICAzLFxuICAwLFxuICA4LFxuICAxMixcbiAgMixcbiAgMTMsXG4gIDcsXG4gIDEsXG4gIDQsXG4gIDEwLFxuICA1LFxuICAxMCxcbiAgMixcbiAgOCxcbiAgNCxcbiAgNyxcbiAgNixcbiAgMSxcbiAgNSxcbiAgMTUsXG4gIDExLFxuICA5LFxuICAxNCxcbiAgMyxcbiAgMTIsXG4gIDEzLFxuICAwXG5dKVxuXG4vLyBDb21wcmVzc2lvbiBmdW5jdGlvbi4gXCJsYXN0XCIgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9ja1xuY29uc3QgdiA9IG5ldyBVaW50MzJBcnJheSgxNilcbmNvbnN0IG0gPSBuZXcgVWludDMyQXJyYXkoMTYpXG5mdW5jdGlvbiBibGFrZTJzQ29tcHJlc3MgKGN0eCwgbGFzdCkge1xuICBsZXQgaSA9IDBcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIC8vIGluaXQgd29yayB2YXJpYWJsZXNcbiAgICB2W2ldID0gY3R4LmhbaV1cbiAgICB2W2kgKyA4XSA9IEJMQUtFMlNfSVZbaV1cbiAgfVxuXG4gIHZbMTJdIF49IGN0eC50IC8vIGxvdyAzMiBiaXRzIG9mIG9mZnNldFxuICB2WzEzXSBePSBjdHgudCAvIDB4MTAwMDAwMDAwIC8vIGhpZ2ggMzIgYml0c1xuICBpZiAobGFzdCkge1xuICAgIC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICAgIHZbMTRdID0gfnZbMTRdXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIC8vIGdldCBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gICAgbVtpXSA9IEIyU19HRVQzMihjdHguYiwgNCAqIGkpXG4gIH1cblxuICAvLyB0ZW4gcm91bmRzIG9mIG1peGluZ1xuICAvLyB1bmNvbW1lbnQgdGhlIERlYnVnUHJpbnQgY2FsbHMgdG8gbG9nIHRoZSBjb21wdXRhdGlvblxuICAvLyBhbmQgbWF0Y2ggdGhlIFJGQyBzYW1wbGUgZG9jdW1lbnRhdGlvblxuICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgICAgICAgICBtWzE2XScsIG0sIDMyKVxuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIC8vIHV0aWwuZGVidWdQcmludCgnICAgKGk9JyArIGkgKyAnKSAgdlsxNl0nLCB2LCAzMilcbiAgICBCMlNfRygwLCA0LCA4LCAxMiwgbVtTSUdNQVtpICogMTYgKyAwXV0sIG1bU0lHTUFbaSAqIDE2ICsgMV1dKVxuICAgIEIyU19HKDEsIDUsIDksIDEzLCBtW1NJR01BW2kgKiAxNiArIDJdXSwgbVtTSUdNQVtpICogMTYgKyAzXV0pXG4gICAgQjJTX0coMiwgNiwgMTAsIDE0LCBtW1NJR01BW2kgKiAxNiArIDRdXSwgbVtTSUdNQVtpICogMTYgKyA1XV0pXG4gICAgQjJTX0coMywgNywgMTEsIDE1LCBtW1NJR01BW2kgKiAxNiArIDZdXSwgbVtTSUdNQVtpICogMTYgKyA3XV0pXG4gICAgQjJTX0coMCwgNSwgMTAsIDE1LCBtW1NJR01BW2kgKiAxNiArIDhdXSwgbVtTSUdNQVtpICogMTYgKyA5XV0pXG4gICAgQjJTX0coMSwgNiwgMTEsIDEyLCBtW1NJR01BW2kgKiAxNiArIDEwXV0sIG1bU0lHTUFbaSAqIDE2ICsgMTFdXSlcbiAgICBCMlNfRygyLCA3LCA4LCAxMywgbVtTSUdNQVtpICogMTYgKyAxMl1dLCBtW1NJR01BW2kgKiAxNiArIDEzXV0pXG4gICAgQjJTX0coMywgNCwgOSwgMTQsIG1bU0lHTUFbaSAqIDE2ICsgMTRdXSwgbVtTSUdNQVtpICogMTYgKyAxNV1dKVxuICB9XG4gIC8vIHV0aWwuZGVidWdQcmludCgnICAgKGk9MTApIHZbMTZdJywgdiwgMzIpXG5cbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGN0eC5oW2ldIF49IHZbaV0gXiB2W2kgKyA4XVxuICB9XG4gIC8vIHV0aWwuZGVidWdQcmludCgnaFs4XScsIGN0eC5oLCAzMilcbn1cblxuLy8gQ3JlYXRlcyBhIEJMQUtFMnMgaGFzaGluZyBjb250ZXh0XG4vLyBSZXF1aXJlcyBhbiBvdXRwdXQgbGVuZ3RoIGJldHdlZW4gMSBhbmQgMzIgYnl0ZXNcbi8vIFRha2VzIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkga2V5XG5mdW5jdGlvbiBibGFrZTJzSW5pdCAob3V0bGVuLCBrZXkpIHtcbiAgaWYgKCEob3V0bGVuID4gMCAmJiBvdXRsZW4gPD0gMzIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3Qgb3V0cHV0IGxlbmd0aCwgc2hvdWxkIGJlIGluIFsxLCAzMl0nKVxuICB9XG4gIGNvbnN0IGtleWxlbiA9IGtleSA/IGtleS5sZW5ndGggOiAwXG4gIGlmIChrZXkgJiYgIShrZXlsZW4gPiAwICYmIGtleWxlbiA8PSAzMikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBrZXkgbGVuZ3RoLCBzaG91bGQgYmUgaW4gWzEsIDMyXScpXG4gIH1cblxuICBjb25zdCBjdHggPSB7XG4gICAgaDogbmV3IFVpbnQzMkFycmF5KEJMQUtFMlNfSVYpLCAvLyBoYXNoIHN0YXRlXG4gICAgYjogbmV3IFVpbnQ4QXJyYXkoNjQpLCAvLyBpbnB1dCBibG9ja1xuICAgIGM6IDAsIC8vIHBvaW50ZXIgd2l0aGluIGJsb2NrXG4gICAgdDogMCwgLy8gaW5wdXQgY291bnRcbiAgICBvdXRsZW46IG91dGxlbiAvLyBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzXG4gIH1cbiAgY3R4LmhbMF0gXj0gMHgwMTAxMDAwMCBeIChrZXlsZW4gPDwgOCkgXiBvdXRsZW5cblxuICBpZiAoa2V5bGVuID4gMCkge1xuICAgIGJsYWtlMnNVcGRhdGUoY3R4LCBrZXkpXG4gICAgY3R4LmMgPSA2NCAvLyBhdCB0aGUgZW5kXG4gIH1cblxuICByZXR1cm4gY3R4XG59XG5cbi8vIFVwZGF0ZXMgYSBCTEFLRTJzIHN0cmVhbWluZyBoYXNoXG4vLyBSZXF1aXJlcyBoYXNoIGNvbnRleHQgYW5kIFVpbnQ4QXJyYXkgKGJ5dGUgYXJyYXkpXG5mdW5jdGlvbiBibGFrZTJzVXBkYXRlIChjdHgsIGlucHV0KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY3R4LmMgPT09IDY0KSB7XG4gICAgICAvLyBidWZmZXIgZnVsbCA/XG4gICAgICBjdHgudCArPSBjdHguYyAvLyBhZGQgY291bnRlcnNcbiAgICAgIGJsYWtlMnNDb21wcmVzcyhjdHgsIGZhbHNlKSAvLyBjb21wcmVzcyAobm90IGxhc3QpXG4gICAgICBjdHguYyA9IDAgLy8gY291bnRlciB0byB6ZXJvXG4gICAgfVxuICAgIGN0eC5iW2N0eC5jKytdID0gaW5wdXRbaV1cbiAgfVxufVxuXG4vLyBDb21wbGV0ZXMgYSBCTEFLRTJzIHN0cmVhbWluZyBoYXNoXG4vLyBSZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBtZXNzYWdlIGRpZ2VzdFxuZnVuY3Rpb24gYmxha2Uyc0ZpbmFsIChjdHgpIHtcbiAgY3R4LnQgKz0gY3R4LmMgLy8gbWFyayBsYXN0IGJsb2NrIG9mZnNldFxuICB3aGlsZSAoY3R4LmMgPCA2NCkge1xuICAgIC8vIGZpbGwgdXAgd2l0aCB6ZXJvc1xuICAgIGN0eC5iW2N0eC5jKytdID0gMFxuICB9XG4gIGJsYWtlMnNDb21wcmVzcyhjdHgsIHRydWUpIC8vIGZpbmFsIGJsb2NrIGZsYWcgPSAxXG5cbiAgLy8gbGl0dGxlIGVuZGlhbiBjb252ZXJ0IGFuZCBzdG9yZVxuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShjdHgub3V0bGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGN0eC5vdXRsZW47IGkrKykge1xuICAgIG91dFtpXSA9IChjdHguaFtpID4+IDJdID4+ICg4ICogKGkgJiAzKSkpICYgMHhmZlxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuLy8gQ29tcHV0ZXMgdGhlIEJMQUtFMlMgaGFzaCBvZiBhIHN0cmluZyBvciBieXRlIGFycmF5LCBhbmQgcmV0dXJucyBhIFVpbnQ4QXJyYXlcbi8vXG4vLyBSZXR1cm5zIGEgbi1ieXRlIFVpbnQ4QXJyYXlcbi8vXG4vLyBQYXJhbWV0ZXJzOlxuLy8gLSBpbnB1dCAtIHRoZSBpbnB1dCBieXRlcywgYXMgYSBzdHJpbmcsIEJ1ZmZlciwgb3IgVWludDhBcnJheVxuLy8gLSBrZXkgLSBvcHRpb25hbCBrZXkgVWludDhBcnJheSwgdXAgdG8gMzIgYnl0ZXNcbi8vIC0gb3V0bGVuIC0gb3B0aW9uYWwgb3V0cHV0IGxlbmd0aCBpbiBieXRlcywgZGVmYXVsdCA2NFxuZnVuY3Rpb24gYmxha2UycyAoaW5wdXQsIGtleSwgb3V0bGVuKSB7XG4gIC8vIHByZXByb2Nlc3MgaW5wdXRzXG4gIG91dGxlbiA9IG91dGxlbiB8fCAzMlxuICBpbnB1dCA9IHV0aWwubm9ybWFsaXplSW5wdXQoaW5wdXQpXG5cbiAgLy8gZG8gdGhlIG1hdGhcbiAgY29uc3QgY3R4ID0gYmxha2Uyc0luaXQob3V0bGVuLCBrZXkpXG4gIGJsYWtlMnNVcGRhdGUoY3R4LCBpbnB1dClcbiAgcmV0dXJuIGJsYWtlMnNGaW5hbChjdHgpXG59XG5cbi8vIENvbXB1dGVzIHRoZSBCTEFLRTJTIGhhc2ggb2YgYSBzdHJpbmcgb3IgYnl0ZSBhcnJheVxuLy9cbi8vIFJldHVybnMgYW4gbi1ieXRlIGhhc2ggaW4gaGV4LCBhbGwgbG93ZXJjYXNlXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vIC0gaW5wdXQgLSB0aGUgaW5wdXQgYnl0ZXMsIGFzIGEgc3RyaW5nLCBCdWZmZXIsIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDMyIGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbmZ1bmN0aW9uIGJsYWtlMnNIZXggKGlucHV0LCBrZXksIG91dGxlbikge1xuICBjb25zdCBvdXRwdXQgPSBibGFrZTJzKGlucHV0LCBrZXksIG91dGxlbilcbiAgcmV0dXJuIHV0aWwudG9IZXgob3V0cHV0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYmxha2UyczogYmxha2UycyxcbiAgYmxha2Uyc0hleDogYmxha2Uyc0hleCxcbiAgYmxha2Uyc0luaXQ6IGJsYWtlMnNJbml0LFxuICBibGFrZTJzVXBkYXRlOiBibGFrZTJzVXBkYXRlLFxuICBibGFrZTJzRmluYWw6IGJsYWtlMnNGaW5hbFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/blakejs/blake2s.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/blakejs/index.js":
/*!***************************************!*\
  !*** ./node_modules/blakejs/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const b2b = __webpack_require__(/*! ./blake2b */ \"(ssr)/./node_modules/blakejs/blake2b.js\")\nconst b2s = __webpack_require__(/*! ./blake2s */ \"(ssr)/./node_modules/blakejs/blake2s.js\")\n\nmodule.exports = {\n  blake2b: b2b.blake2b,\n  blake2bHex: b2b.blake2bHex,\n  blake2bInit: b2b.blake2bInit,\n  blake2bUpdate: b2b.blake2bUpdate,\n  blake2bFinal: b2b.blake2bFinal,\n  blake2s: b2s.blake2s,\n  blake2sHex: b2s.blake2sHex,\n  blake2sInit: b2s.blake2sInit,\n  blake2sUpdate: b2s.blake2sUpdate,\n  blake2sFinal: b2s.blake2sFinal\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmxha2Vqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsMERBQVc7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLDBEQUFXOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXVuY2hwYWQtcmFkaXgvLi9ub2RlX21vZHVsZXMvYmxha2Vqcy9pbmRleC5qcz9iMGY4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGIyYiA9IHJlcXVpcmUoJy4vYmxha2UyYicpXG5jb25zdCBiMnMgPSByZXF1aXJlKCcuL2JsYWtlMnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYmxha2UyYjogYjJiLmJsYWtlMmIsXG4gIGJsYWtlMmJIZXg6IGIyYi5ibGFrZTJiSGV4LFxuICBibGFrZTJiSW5pdDogYjJiLmJsYWtlMmJJbml0LFxuICBibGFrZTJiVXBkYXRlOiBiMmIuYmxha2UyYlVwZGF0ZSxcbiAgYmxha2UyYkZpbmFsOiBiMmIuYmxha2UyYkZpbmFsLFxuICBibGFrZTJzOiBiMnMuYmxha2UycyxcbiAgYmxha2Uyc0hleDogYjJzLmJsYWtlMnNIZXgsXG4gIGJsYWtlMnNJbml0OiBiMnMuYmxha2Uyc0luaXQsXG4gIGJsYWtlMnNVcGRhdGU6IGIycy5ibGFrZTJzVXBkYXRlLFxuICBibGFrZTJzRmluYWw6IGIycy5ibGFrZTJzRmluYWxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/blakejs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/blakejs/util.js":
/*!**************************************!*\
  !*** ./node_modules/blakejs/util.js ***!
  \**************************************/
/***/ ((module) => {

eval("const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'\n\n// For convenience, let people hash a string, not just a Uint8Array\nfunction normalizeInput (input) {\n  let ret\n  if (input instanceof Uint8Array) {\n    ret = input\n  } else if (typeof input === 'string') {\n    const encoder = new TextEncoder()\n    ret = encoder.encode(input)\n  } else {\n    throw new Error(ERROR_MSG_INPUT)\n  }\n  return ret\n}\n\n// Converts a Uint8Array to a hexadecimal string\n// For example, toHex([255, 0, 255]) returns \"ff00ff\"\nfunction toHex (bytes) {\n  return Array.prototype.map\n    .call(bytes, function (n) {\n      return (n < 16 ? '0' : '') + n.toString(16)\n    })\n    .join('')\n}\n\n// Converts any value in [0...2^32-1] to an 8-character hex string\nfunction uint32ToHex (val) {\n  return (0x100000000 + val).toString(16).substring(1)\n}\n\n// For debugging: prints out hash state in the same format as the RFC\n// sample computation exactly, so that you can diff\nfunction debugPrint (label, arr, size) {\n  let msg = '\\n' + label + ' = '\n  for (let i = 0; i < arr.length; i += 2) {\n    if (size === 32) {\n      msg += uint32ToHex(arr[i]).toUpperCase()\n      msg += ' '\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n    } else if (size === 64) {\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n      msg += uint32ToHex(arr[i]).toUpperCase()\n    } else throw new Error('Invalid size ' + size)\n    if (i % 6 === 4) {\n      msg += '\\n' + new Array(label.length + 4).join(' ')\n    } else if (i < arr.length - 2) {\n      msg += ' '\n    }\n  }\n  console.log(msg)\n}\n\n// For performance testing: generates N bytes of input, hashes M times\n// Measures and prints MB/second hash performance each time\nfunction testSpeed (hashFn, N, M) {\n  let startMs = new Date().getTime()\n\n  const input = new Uint8Array(N)\n  for (let i = 0; i < N; i++) {\n    input[i] = i % 256\n  }\n  const genMs = new Date().getTime()\n  console.log('Generated random input in ' + (genMs - startMs) + 'ms')\n  startMs = genMs\n\n  for (let i = 0; i < M; i++) {\n    const hashHex = hashFn(input)\n    const hashMs = new Date().getTime()\n    const ms = hashMs - startMs\n    startMs = hashMs\n    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')\n    console.log(\n      Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'\n    )\n  }\n}\n\nmodule.exports = {\n  normalizeInput: normalizeInput,\n  toHex: toHex,\n  debugPrint: debugPrint,\n  testSpeed: testSpeed\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmxha2Vqcy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhdW5jaHBhZC1yYWRpeC8uL25vZGVfbW9kdWxlcy9ibGFrZWpzL3V0aWwuanM/OGE3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFUlJPUl9NU0dfSU5QVVQgPSAnSW5wdXQgbXVzdCBiZSBhbiBzdHJpbmcsIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuXG4vLyBGb3IgY29udmVuaWVuY2UsIGxldCBwZW9wbGUgaGFzaCBhIHN0cmluZywgbm90IGp1c3QgYSBVaW50OEFycmF5XG5mdW5jdGlvbiBub3JtYWxpemVJbnB1dCAoaW5wdXQpIHtcbiAgbGV0IHJldFxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0ID0gaW5wdXRcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4gICAgcmV0ID0gZW5jb2Rlci5lbmNvZGUoaW5wdXQpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR19JTlBVVClcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8vIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIGhleGFkZWNpbWFsIHN0cmluZ1xuLy8gRm9yIGV4YW1wbGUsIHRvSGV4KFsyNTUsIDAsIDI1NV0pIHJldHVybnMgXCJmZjAwZmZcIlxuZnVuY3Rpb24gdG9IZXggKGJ5dGVzKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwXG4gICAgLmNhbGwoYnl0ZXMsIGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gKG4gPCAxNiA/ICcwJyA6ICcnKSArIG4udG9TdHJpbmcoMTYpXG4gICAgfSlcbiAgICAuam9pbignJylcbn1cblxuLy8gQ29udmVydHMgYW55IHZhbHVlIGluIFswLi4uMl4zMi0xXSB0byBhbiA4LWNoYXJhY3RlciBoZXggc3RyaW5nXG5mdW5jdGlvbiB1aW50MzJUb0hleCAodmFsKSB7XG4gIHJldHVybiAoMHgxMDAwMDAwMDAgKyB2YWwpLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSlcbn1cblxuLy8gRm9yIGRlYnVnZ2luZzogcHJpbnRzIG91dCBoYXNoIHN0YXRlIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgUkZDXG4vLyBzYW1wbGUgY29tcHV0YXRpb24gZXhhY3RseSwgc28gdGhhdCB5b3UgY2FuIGRpZmZcbmZ1bmN0aW9uIGRlYnVnUHJpbnQgKGxhYmVsLCBhcnIsIHNpemUpIHtcbiAgbGV0IG1zZyA9ICdcXG4nICsgbGFiZWwgKyAnID0gJ1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChzaXplID09PSAzMikge1xuICAgICAgbXNnICs9IHVpbnQzMlRvSGV4KGFycltpXSkudG9VcHBlckNhc2UoKVxuICAgICAgbXNnICs9ICcgJ1xuICAgICAgbXNnICs9IHVpbnQzMlRvSGV4KGFycltpICsgMV0pLnRvVXBwZXJDYXNlKClcbiAgICB9IGVsc2UgaWYgKHNpemUgPT09IDY0KSB7XG4gICAgICBtc2cgKz0gdWludDMyVG9IZXgoYXJyW2kgKyAxXSkudG9VcHBlckNhc2UoKVxuICAgICAgbXNnICs9IHVpbnQzMlRvSGV4KGFycltpXSkudG9VcHBlckNhc2UoKVxuICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2l6ZSAnICsgc2l6ZSlcbiAgICBpZiAoaSAlIDYgPT09IDQpIHtcbiAgICAgIG1zZyArPSAnXFxuJyArIG5ldyBBcnJheShsYWJlbC5sZW5ndGggKyA0KS5qb2luKCcgJylcbiAgICB9IGVsc2UgaWYgKGkgPCBhcnIubGVuZ3RoIC0gMikge1xuICAgICAgbXNnICs9ICcgJ1xuICAgIH1cbiAgfVxuICBjb25zb2xlLmxvZyhtc2cpXG59XG5cbi8vIEZvciBwZXJmb3JtYW5jZSB0ZXN0aW5nOiBnZW5lcmF0ZXMgTiBieXRlcyBvZiBpbnB1dCwgaGFzaGVzIE0gdGltZXNcbi8vIE1lYXN1cmVzIGFuZCBwcmludHMgTUIvc2Vjb25kIGhhc2ggcGVyZm9ybWFuY2UgZWFjaCB0aW1lXG5mdW5jdGlvbiB0ZXN0U3BlZWQgKGhhc2hGbiwgTiwgTSkge1xuICBsZXQgc3RhcnRNcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG5cbiAgY29uc3QgaW5wdXQgPSBuZXcgVWludDhBcnJheShOKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgIGlucHV0W2ldID0gaSAlIDI1NlxuICB9XG4gIGNvbnN0IGdlbk1zID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgY29uc29sZS5sb2coJ0dlbmVyYXRlZCByYW5kb20gaW5wdXQgaW4gJyArIChnZW5NcyAtIHN0YXJ0TXMpICsgJ21zJylcbiAgc3RhcnRNcyA9IGdlbk1zXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNOyBpKyspIHtcbiAgICBjb25zdCBoYXNoSGV4ID0gaGFzaEZuKGlucHV0KVxuICAgIGNvbnN0IGhhc2hNcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgY29uc3QgbXMgPSBoYXNoTXMgLSBzdGFydE1zXG4gICAgc3RhcnRNcyA9IGhhc2hNc1xuICAgIGNvbnNvbGUubG9nKCdIYXNoZWQgaW4gJyArIG1zICsgJ21zOiAnICsgaGFzaEhleC5zdWJzdHJpbmcoMCwgMjApICsgJy4uLicpXG4gICAgY29uc29sZS5sb2coXG4gICAgICBNYXRoLnJvdW5kKChOIC8gKDEgPDwgMjApIC8gKG1zIC8gMTAwMCkpICogMTAwKSAvIDEwMCArICcgTUIgUEVSIFNFQ09ORCdcbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vcm1hbGl6ZUlucHV0OiBub3JtYWxpemVJbnB1dCxcbiAgdG9IZXg6IHRvSGV4LFxuICBkZWJ1Z1ByaW50OiBkZWJ1Z1ByaW50LFxuICB0ZXN0U3BlZWQ6IHRlc3RTcGVlZFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/blakejs/util.js\n");

/***/ })

};
;